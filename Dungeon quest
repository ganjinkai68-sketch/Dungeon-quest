-- Rayfield Interface Setup
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Dungeon Quest",
    LoadingTitle = "Dungeon Quest Hub",
    LoadingSubtitle = "by Hack Studio",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "DungeonQuest",
        FileName = "Config"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false,
})

-- Wait for game to load
repeat task.wait() until game:IsLoaded()

-- Locals
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local WaitingToTp = false
local GreggCoin, RealCoin = false, nil
local oldTick = tick()
local BestDungeon, BestDifficulty = "Desert Temple", "Easy"
local NameHideName, NameHideTitle = "Float.Balls", "ðŸ¤–"
local LastPlayerPos, StuckTime = Vector3.zero, 0
local PlayerGui = Player.PlayerGui
local OldName, OldTitle

-- Settings
local Settings = {
    AutoFarm = {
        Enabled = false,
        Delay = 2,
        Distance = 6,
        UseSkills = false,
        RaidFarm = false
    },
    Dungeon = {
        Enabled = false,
        EnabledBest = false,
        Name = "",
        Difficulty = "",
        Mode = "Normal",
        RaidEnabled = false,
        RaidName = "",
        Tier = "1"
    },
    AutoSell = {
        Enabled = false,
        Raritys = {},
        ItemTypes = {}
    },
    Misc = {
        AutoRetry = false,
        GetGreggCoin = false,
        NameHide = false,
        RejoinIfStuck = false,
        RejoinStuckDelay = 120,
        NoClip = false,
        RemoveBarriers = false,
        HideMap = true  -- NEW: Auto hide map setting
    }
}

-- FPS Boost Function - Automatically applied
local function ApplyFPSBoost()
    -- Set low graphics quality
    settings().Rendering.QualityLevel = 1
    
    -- Remove unnecessary visual effects
    for _, effect in pairs(workspace:GetDescendants()) do
        if effect:IsA("ParticleEmitter") or effect:IsA("Fire") or effect:IsA("Smoke") or effect:IsA("Sparkles") then
            effect.Enabled = false
        end
    end
    
    -- Remove decorative parts that aren't mobs or essential
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Part") then
            -- Keep only essential parts: mobs, dungeon structure, coins
            if not string.find(obj.Name:lower(), "enemy") and 
               not string.find(obj.Name:lower(), "mob") and 
               not string.find(obj.Name:lower(), "boss") and
               not string.find(obj.Name:lower(), "coin") and
               not string.find(obj.Name:lower(), "dungeon") and
               not string.find(obj.Name:lower(), "barrier") and
               obj.Name ~= "HumanoidRootPart" and
               obj.Name ~= "Head" then
                if obj.Transparency < 1 then
                    obj.Transparency = 0.8
                end
                if obj.Material ~= Enum.Material.Plastic then
                    obj.Material = Enum.Material.Plastic
                end
            end
        end
    end
    
    -- Disable shadows
    game:GetService("Lighting").GlobalShadows = false
    game:GetService("Lighting").Technology = Enum.Technology.Compatibility
    
    -- Reduce terrain detail
    if workspace:FindFirstChildOfClass("Terrain") then
        workspace.Terrain.Decoration = false
        workspace.Terrain.WaterReflection = false
        workspace.Terrain.WaterWave = false
    end
end

-- NEW: Auto Hide Map Function
local function HideMapObjects()
    if not Settings.Misc.HideMap then return end
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") then
            -- Hide decorative map objects but keep essential ones
            if not string.find(obj.Name:lower(), "enemy") and 
               not string.find(obj.Name:lower(), "mob") and 
               not string.find(obj.Name:lower(), "boss") and
               not string.find(obj.Name:lower(), "coin") and
               not string.find(obj.Name:lower(), "barrier") and
               not string.find(obj.Name:lower(), "spawn") and
               not string.find(obj.Name:lower(), "checkpoint") and
               not string.find(obj.Name:lower(), "door") and
               not string.find(obj.Name:lower(), "portal") and
               obj.Name ~= "HumanoidRootPart" and
               obj.Name ~= "Head" and
               obj.Name ~= "Torso" and
               obj.Name ~= "Left Arm" and
               obj.Name ~= "Right Arm" and
               obj.Name ~= "Left Leg" and
               obj.Name ~= "Right Leg" then
                
                -- Make decorative objects transparent
                if obj.Transparency < 0.9 then
                    obj.Transparency = 0.9
                end
                
                -- Remove collision from decorative objects
                if obj.CanCollide then
                    obj.CanCollide = false
                end
            end
        elseif obj:IsA("ParticleEmitter") or obj:IsA("Fire") or obj:IsA("Smoke") then
            -- Hide all particle effects
            obj.Enabled = false
        elseif obj:IsA("Decal") then
            -- Hide decorative textures
            obj.Transparency = 1
        end
    end
end

-- Apply FPS boost and map hiding immediately and continuously
spawn(function()
    ApplyFPSBoost()
    while true do
        task.wait(3) -- Reapply every 3 seconds to catch new objects
        ApplyFPSBoost()
        HideMapObjects()
    end
end)

-- Dungeon Levels
local DungeonLevels = {
    ["0"] = {["Dungeon"] = "Desert Temple", ["Easy"] = 0, ["Medium"] = 5, ["Hard"] = 15},
    ["30"] = {["Dungeon"] = "Winter Outpost", ["Easy"] = 30, ["Medium"] = 40, ["Hard"] = 50},
    ["60"] = {["Dungeon"] = "Pirate Island", ["Insane"] = 60, ["Nightmare"] = 65},
    ["70"] = {["Dungeon"] = "King's Castle", ["Insane"] = 70, ["Nightmare"] = 75},
    ["80"] = {["Dungeon"] = "The Underworld", ["Insane"] = 80, ["Nightmare"] = 85},
    ["90"] = {["Dungeon"] = "Samurai Palace", ["Insane"] = 90, ["Nightmare"] = 95},
    ["100"] = {["Dungeon"] = "The Canals", ["Insane"] = 100, ["Nightmare"] = 105},
    ["110"] = {["Dungeon"] = "Ghastly Harbor", ["Insane"] = 110, ["Nightmare"] = 115},
    ["120"] = {["Dungeon"] = "Steampunk Sewers", ["Insane"] = 120, ["Nightmare"] = 125},
    ["135"] = {["Dungeon"] = "Orbital Outpost", ["Insane"] = 135, ["Nightmare"] = 140},
    ["150"] = {["Dungeon"] = "Volcanic Chambers", ["Insane"] = 150, ["Nightmare"] = 155},   
    ["160"] = {["Dungeon"] = "Aquatic Temple", ["Insane"] = 160, ["Nightmare"] = 165},
    ["170"] = {["Dungeon"] = "Enchanted Forest", ["Insane"] = 170, ["Nightmare"] = 175},
    ["180"] = {["Dungeon"] = "Northern Lands", ["Insane"] = 180, ["Nightmare"] = 185},
    ["190"] = {["Dungeon"] = "Gilded Skies", ["Insane"] = 190, ["Nightmare"] = 195},
    ["200"] = {["Dungeon"] = "Yokai Peak", ["Insane"] = 200, ["Nightmare"] = 205},
    ["210"] = {["Dungeon"] = "Abyssal Void", ["Insane"] = 210, ["Nightmare"] = 215},
}

-- Character handling
Player.CharacterAdded:Connect(function(char)
    Character = char
    repeat task.wait() until Character:FindFirstChild("HumanoidRootPart")
end)

-- Functions
local function GetBestDungeon()
    local highestLevelDungeon = 0
    for level, data in pairs(DungeonLevels) do
        if Player.leaderstats.Level.Value >= tonumber(level) then
            if tonumber(level) > highestLevelDungeon then
                highestLevelDungeon = tonumber(level)
                if data["Nightmare"] and Player.leaderstats.Level.Value >= data["Nightmare"] then
                    BestDungeon = data["Dungeon"]
                    BestDifficulty = "Nightmare"
                elseif data["Insane"] and Player.leaderstats.Level.Value >= data["Insane"] then
                    BestDungeon = data["Dungeon"]
                    BestDifficulty = "Insane"
                elseif data["Hard"] and Player.leaderstats.Level.Value >= data["Hard"] then
                    BestDungeon = data["Dungeon"]
                    BestDifficulty = "Hard"
                elseif data["Medium"] and Player.leaderstats.Level.Value >= data["Medium"] then
                    BestDungeon = data["Dungeon"]
                    BestDifficulty = "Medium"
                elseif data["Easy"] and Player.leaderstats.Level.Value >= data["Easy"] then
                    BestDungeon = data["Dungeon"]
                    BestDifficulty = "Easy"
                end
            end
        end
    end
    return BestDungeon, BestDifficulty
end

local function GetEnemies()
    if not workspace:FindFirstChild("dungeon") then 
        return workspace:FindFirstChild("enemies"):GetChildren()
    end
    for _, v in pairs(workspace.dungeon:GetChildren()) do
        if v:FindFirstChild("enemyFolder") and v.enemyFolder:FindFirstChildOfClass("Model") then
            return v.enemyFolder:GetChildren()
        end
    end
    return nil
end

local function GetClosestEnemy()
    if not Character:FindFirstChild("HumanoidRootPart") then return end
    if GetEnemies() == nil then return end

    local closestEnemy = nil
    local highestHealthEnemy = nil
    local shortestDistance = math.huge
    local maxHealth = -math.huge
    for _, v in pairs(GetEnemies()) do
        local enemyPosition = v:FindFirstChild("HumanoidRootPart") and v.HumanoidRootPart.Position
        local enemyHumanoid = v:FindFirstChild("Humanoid")
        if enemyPosition and enemyHumanoid then
            local distance = (Character.HumanoidRootPart.Position - enemyPosition).Magnitude
            if distance < shortestDistance or (distance == shortestDistance and enemyHumanoid.MaxHealth > maxHealth) then
                shortestDistance = distance
                closestEnemy = v
                maxHealth = enemyHumanoid.MaxHealth
            end
        end
    end

    return closestEnemy
end

-- EXACT Teleport function from reference script
local function Teleport(Cframe)
    if not Character:FindFirstChild("HumanoidRootPart") then return end
    LastPlayerPos = Character:GetPivot().p
    if WaitingToTp == true then return end
    local bodyPosition = Character.HumanoidRootPart:FindFirstChildOfClass("BodyPosition")
    local bodyGyro = Character.HumanoidRootPart:FindFirstChildOfClass("BodyGyro")
    if not Character.HumanoidRootPart:FindFirstChildOfClass("BodyGyro") then
        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
        bodyGyro.CFrame = Character.HumanoidRootPart.CFrame
        bodyGyro.D = 500
        bodyGyro.Parent = Character.HumanoidRootPart
    end
    if not Character.HumanoidRootPart:FindFirstChildOfClass("BodyPosition") then
        bodyPosition = Instance.new("BodyPosition")
        bodyPosition.MaxForce = Vector3.new(400000, 400000, 400000)
        bodyPosition.Position = Cframe.Position
        bodyPosition.D = 300
        bodyPosition.Parent = Character.HumanoidRootPart
        Character.HumanoidRootPart.Velocity = Vector3.zero
    end
    local oldTime = tick()
    WaitingToTp = true
    Character.HumanoidRootPart.Anchored = false
    repeat task.wait()
        if Character:FindFirstChild("HumanoidRootPart") and bodyPosition ~= nil and bodyGyro ~= nil then
            Character:PivotTo(CFrame.new(Cframe.p + Vector3.new(0, Settings.AutoFarm.Distance * 2, 0)) * CFrame.Angles(math.rad(90), 0, 0))
            bodyPosition.Position = Cframe.Position + Vector3.new(0, Settings.AutoFarm.Distance * 2, 0)
            bodyGyro.CFrame = CFrame.new(Character:GetPivot().p, Cframe.Position) * CFrame.Angles(math.rad(90), 0, 0)
        end
    until tick() - oldTime >= Settings.AutoFarm.Delay or not Character:FindFirstChild("HumanoidRootPart")
    WaitingToTp = false
    if Character:FindFirstChild("HumanoidRootPart") then
        Character.HumanoidRootPart.Anchored = true
        bodyPosition:Destroy()
    end
end

-- DoSkills function - 10 times spam
local function DoSkills()
    for _, v in pairs(Player.Backpack:GetChildren()) do
        for i = 0, 10 do
            task.spawn(function()
                if v:FindFirstChild("cooldown") and v.cooldown.Value and (v:FindFirstChild("abilityEvent") or v:FindFirstChild("spellEvent")) then
                    (v:FindFirstChild("abilityEvent") or v:FindFirstChild("spellEvent")):FireServer()
                elseif v:FindFirstChild("cooldown") and v.cooldown.Value then
                    game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer({[1] = {["\t"] = v},[2] = "G"})
                end
            end)
        end
    end
    task.wait()
end

-- Proper Dungeon Creation Function using the game's remote system
local function CreateDungeon(dungeonName, difficulty, mode, isRaid, raidTier)
    if isRaid then
        -- Create Raid Lobby
        local raidArgs = {
            [1] = {
                [1] = {
                    [1] = "\1",
                    [2] = {
                        ["\3"] = "PlaySolo",
                        ["partyData"] = {
                            ["difficulty"] = "Nightmare",
                            ["minimumJoinLevel"] = 0,
                            ["tier"] = raidTier or "1",
                            ["dungeonName"] = dungeonName,
                            ["mode"] = "Raid",
                            ["visibility"] = "Public",
                            ["maxPlayers"] = 40
                        }
                    }
                },
                [2] = "d"
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer(unpack(raidArgs))
    else
        -- Create Normal Dungeon
        local dungeonArgs = {
            [1] = {
                [1] = {
                    [1] = "\1",
                    [2] = {
                        ["\3"] = "PlaySolo",
                        ["partyData"] = {
                            ["difficulty"] = difficulty,
                            ["mode"] = mode,
                            ["dungeonName"] = dungeonName,
                            ["tier"] = 1,
                        }
                    }
                },
                [2] = "d"
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer(unpack(dungeonArgs))
    end
end

local function RemoveBarriers()
    if workspace:FindFirstChild("dungeon") then
        for _, obj in pairs(workspace.dungeon:GetDescendants()) do
            if obj.Name == "barrier" then
                obj:Destroy()
            end
        end
    end
end

-- NoClip Function
local function ApplyNoClip()
    if not Character then return end
    for _, part in pairs(Character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

local function RemoveNoClip()
    if not Character then return end
    for _, part in pairs(Character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

-- Create Tabs
local FarmingTab = Window:CreateTab("Farming", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

-- Auto Farm Section
local AutoFarmSection = FarmingTab:CreateSection("Auto Farm")

local AutoFarmToggle = FarmingTab:CreateToggle({
    Name = "Auto Farm Enabled",
    CurrentValue = false,
    Flag = "AutoFarmToggle",
    Callback = function(Value)
        Settings.AutoFarm.Enabled = Value
    end,
})

local UseSkillsToggle = FarmingTab:CreateToggle({
    Name = "Use Skills",
    CurrentValue = false,
    Flag = "UseSkillsToggle",
    Callback = function(Value)
        Settings.AutoFarm.UseSkills = Value
    end,
})

local RemoveBarriersToggle = FarmingTab:CreateToggle({
    Name = "Remove Barriers",
    CurrentValue = false,
    Flag = "RemoveBarriersToggle",
    Callback = function(Value)
        Settings.Misc.RemoveBarriers = Value
        if Value then
            spawn(function()
                while Settings.Misc.RemoveBarriers do
                    RemoveBarriers()
                    task.wait(0.5)
                end
            end)
        end
    end,
})

FarmingTab:CreateDivider()

local TeleportDelaySlider = FarmingTab:CreateSlider({
    Name = "Teleport Delay",
    Range = {1, 4},
    Increment = 0.1,
    Suffix = "seconds",
    CurrentValue = Settings.AutoFarm.Delay,
    Flag = "TeleportDelay",
    Callback = function(Value)
        Settings.AutoFarm.Delay = Value
    end,
})

local DistanceSlider = FarmingTab:CreateSlider({
    Name = "Distance",
    Range = {0, 10},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = Settings.AutoFarm.Distance,
    Flag = "DistanceSlider",
    Callback = function(Value)
        Settings.AutoFarm.Distance = Value
    end,
})

-- Dungeon Creation Section
local DungeonSection = FarmingTab:CreateSection("Dungeon Creation")

local AutoCreateBestToggle = FarmingTab:CreateToggle({
    Name = "Auto Create Best Dungeon",
    CurrentValue = false,
    Flag = "AutoCreateBestToggle",
    Callback = function(Value)
        Settings.Dungeon.EnabledBest = Value
        if Value then
            Settings.Dungeon.Enabled = false
            Settings.Dungeon.RaidEnabled = false
            Rayfield:Notify({
                Title = "Auto Create Best Enabled",
                Content = "Will create the best available dungeon for your level",
                Duration = 3,
            })
        end
    end,
})

local AutoCreateToggle = FarmingTab:CreateToggle({
    Name = "Auto Create Dungeon",
    CurrentValue = false,
    Flag = "AutoCreateToggle",
    Callback = function(Value)
        Settings.Dungeon.Enabled = Value
        if Value then
            Settings.Dungeon.EnabledBest = false
            Settings.Dungeon.RaidEnabled = false
            Rayfield:Notify({
                Title = "Auto Create Enabled",
                Content = "Will create selected dungeon automatically",
                Duration = 3,
            })
        end
    end,
})

local DungeonNames = {
    "Desert Temple", "Winter Outpost", "Pirate Island", "King's Castle", "The Underworld",
    "Samurai Palace", "The Canals", "Ghastly Harbor", "Steampunk Sewers", "Orbital Outpost",
    "Volcanic Chambers", "Aquatic Temple", "Enchanted Forest", "Northern Lands", "Gilded Skies",
    "Yokai Peak", "Abyssal Void"
}

local DungeonNameDropdown = FarmingTab:CreateDropdown({
    Name = "Dungeon",
    Options = DungeonNames,
    CurrentOption = BestDungeon,
    Flag = "DungeonNameDropdown",
    Callback = function(Value)
        Settings.Dungeon.Name = Value
    end,
})

local DifficultyDropdown = FarmingTab:CreateDropdown({
    Name = "Difficulty",
    Options = {"Easy", "Medium", "Hard", "Insane", "Nightmare"},
    CurrentOption = BestDifficulty,
    Flag = "DifficultyDropdown",
    Callback = function(Value)
        Settings.Dungeon.Difficulty = Value
    end,
})

local ModeDropdown = FarmingTab:CreateDropdown({
    Name = "Mode",
    Options = {"Normal", "Hardcore"},
    CurrentOption = "Normal",
    Flag = "ModeDropdown",
    Callback = function(Value)
        Settings.Dungeon.Mode = Value
    end,
})

FarmingTab:CreateDivider()

local AutoCreateRaidToggle = FarmingTab:CreateToggle({
    Name = "Auto Create Raid",
    CurrentValue = false,
    Flag = "AutoCreateRaidToggle",
    Callback = function(Value)
        Settings.Dungeon.RaidEnabled = Value
        if Value then
            Settings.Dungeon.Enabled = false
            Settings.Dungeon.EnabledBest = false
            Rayfield:Notify({
                Title = "Auto Create Raid Enabled",
                Content = "Will create selected raid automatically",
                Duration = 3,
            })
        end
    end,
})

local RaidDungeonDropdown = FarmingTab:CreateDropdown({
    Name = "Raid Dungeon",
    Options = {"Hela Raid", "Goliath Raid"},
    CurrentOption = "Hela Raid",
    Flag = "RaidDungeonDropdown",
    Callback = function(Value)
        Settings.Dungeon.RaidName = Value
    end,
})

local TierDropdown = FarmingTab:CreateDropdown({
    Name = "Tier",
    Options = {"1", "2", "3", "4", "5"},
    CurrentOption = "1",
    Flag = "TierDropdown",
    Callback = function(Value)
        Settings.Dungeon.Tier = Value
    end,
})

-- Settings Section
local SettingsSection = FarmingTab:CreateSection("Settings")

local AutoRetryToggle = FarmingTab:CreateToggle({
    Name = "Auto Retry",
    CurrentValue = false,
    Flag = "AutoRetryToggle",
    Callback = function(Value)
        Settings.Misc.AutoRetry = Value
    end,
})

local RaidFarmToggle = FarmingTab:CreateToggle({
    Name = "Raid Farm",
    CurrentValue = false,
    Flag = "RaidFarmToggle",
    Callback = function(Value)
        Settings.AutoFarm.RaidFarm = Value
    end,
})

local GetGreggCoinToggle = FarmingTab:CreateToggle({
    Name = "Get Gregg Coin",
    CurrentValue = false,
    Flag = "GetGreggCoinToggle",
    Callback = function(Value)
        Settings.Misc.GetGreggCoin = Value
    end,
})

-- Misc Tab Features
local MiscSection = MiscTab:CreateSection("Misc Features")

local NoClipToggle = MiscTab:CreateToggle({
    Name = "NoClip (Walk Through Walls)",
    CurrentValue = false,
    Flag = "NoClipToggle",
    Callback = function(Value)
        Settings.Misc.NoClip = Value
        if Value then
            ApplyNoClip()
            Rayfield:Notify({
                Title = "NoClip Enabled",
                Content = "You can now walk through walls and obstacles",
                Duration = 3,
            })
        else
            RemoveNoClip()
            Rayfield:Notify({
                Title = "NoClip Disabled",
                Content = "Collision has been restored",
                Duration = 3,
            })
        end
    end,
})

-- NEW: Auto Hide Map Toggle
local HideMapToggle = MiscTab:CreateToggle({
    Name = "Auto Hide Map (FPS Boost)",
    CurrentValue = true,
    Flag = "HideMapToggle",
    Callback = function(Value)
        Settings.Misc.HideMap = Value
        if Value then
            Rayfield:Notify({
                Title = "Map Hiding Enabled",
                Content = "Decorative map objects will be hidden for better FPS",
                Duration = 3,
            })
        end
    end,
})

local NameHideToggle = MiscTab:CreateToggle({
    Name = "Name Hider",
    CurrentValue = false,
    Flag = "NameHideToggle",
    Callback = function(Value)
        Settings.Misc.NameHide = Value
    end,
})

local NameInput = MiscTab:CreateInput({
    Name = "Custom Name",
    PlaceholderText = "Float.Balls",
    RemoveTextAfterFocusLost = false,
    Flag = "NameInput",
    Callback = function(Value)
        NameHideName = Value
    end,
})

local RejoinToggle = MiscTab:CreateToggle({
    Name = "Rejoin When Stuck",
    CurrentValue = false,
    Flag = "RejoinToggle",
    Callback = function(Value)
        Settings.Misc.RejoinIfStuck = Value
    end,
})

local RejoinDelaySlider = MiscTab:CreateSlider({
    Name = "Stuck Time (Seconds)",
    Range = {30, 300},
    Increment = 10,
    Suffix = "s",
    CurrentValue = Settings.Misc.RejoinStuckDelay,
    Flag = "RejoinDelaySlider",
    Callback = function(Value)
        Settings.Misc.RejoinStuckDelay = Value
    end,
})

-- UPDATED Main Auto Farm Loop with working dungeon creation
spawn(function()
    while true do
        task.wait(0.05)
        
        -- Auto Sell (placeholder)
        if Settings.AutoSell.Enabled then
            -- Auto sell logic would go here
        end
        
        -- FIXED Dungeon Creation - Only creates when in character select scene
        if workspace:FindFirstChild("CharacterSelectScene") then
            if Settings.Dungeon.Enabled then
                CreateDungeon(Settings.Dungeon.Name, Settings.Dungeon.Difficulty, Settings.Dungeon.Mode, false)
                task.wait(2) -- Prevent spam
            elseif Settings.Dungeon.RaidEnabled then
                CreateDungeon(Settings.Dungeon.RaidName, "Nightmare", "Raid", true, Settings.Dungeon.Tier)
                task.wait(2) -- Prevent spam
            elseif Settings.Dungeon.EnabledBest then
                local BestDungeon, BestDifficulty = GetBestDungeon()
                CreateDungeon(BestDungeon, BestDifficulty, "Normal", false)
                task.wait(2) -- Prevent spam
            end
        end
        
        -- Auto Farm
        if not workspace:FindFirstChild("CharacterSelectScene") and Settings.AutoFarm.Enabled and Character == Player.Character and Character:FindFirstChild("HumanoidRootPart") then
            if Player.PlayerGui.HUD.Main.StartButton.Visible == true or Player.PlayerGui.RaidReadyCheck.Enabled == true then
                game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer({[1] = {[utf8.char(3)] = "vote",["vote"] = true},[2] = utf8.char(28)})
                game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer() 
                game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack({[1] = {["\3"] = "raidReady"},[2] = ";"}))        
                game:GetService("ReplicatedStorage"):WaitForChild("Utility"):WaitForChild("AssetRequester"):WaitForChild("Remote"):InvokeServer({[1] = "ui",[2] = "raidTimeLeftGui"})                  
            end
            if Settings.AutoFarm.UseSkills == true then
                DoSkills()
            end
            if Settings.Misc.GetGreggCoin == true and GreggCoin == true and RealCoin ~= nil then
                Teleport(RealCoin:GetPivot() - Vector3.new(0, Settings.AutoFarm.Distance * 2, 0))
                GreggCoin = false
                RealCoin = nil
            end
            local Enemy = GetClosestEnemy()
            if GreggCoin == false and Enemy ~= nil then
                Teleport(GetClosestEnemy():GetPivot())
            end
        end
    end
end)

-- Rejoin when stuck
spawn(function()
    while true do
        task.wait(1)
        if Settings.Misc.RejoinIfStuck == true then
            if LastPlayerPos and Character and (LastPlayerPos - Character:GetPivot().p).Magnitude < 1 then
                StuckTime = StuckTime + 1
            elseif StuckTime == Settings.Misc.RejoinStuckDelay then
                game:GetService("TeleportService"):Teleport(game.PlaceId, Player)
            else
                StuckTime = 0
            end
        end
    end
end)

-- Name hider
spawn(function()
    while true do
        task.wait()
        if Character and Character:FindFirstChild("Head") and Character.Head:FindFirstChild("playerNameplate") and Player.PlayerGui:FindFirstChild("HUD") then
            if Settings.Misc.NameHide == true then
                if Player.PlayerGui.HUD.Main.PlayerStatus.PlayerStatus.PlayerName then
                    Player.PlayerGui.HUD.Main.PlayerStatus.PlayerStatus.PlayerName.Text = NameHideName
                end
                Character.Head.playerNameplate.PlayerName.Text = NameHideName
                Character.Head.playerNameplate.Title.Text = NameHideTitle
            end
        end
    end
end)

-- Auto retry
Player.PlayerGui:WaitForChild("RetryVote").Changed:Connect(function(change)
    if change == "Enabled" and Settings.Misc.AutoRetry then
        game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer({
            [1] = {["\3"] = "vote", ["vote"] = true},
            [2] = "/"
        })
    end
end)

-- Cutscene skip
Player.PlayerGui.cutscene.Changed:Connect(function(change)
    if change == "Enabled" then
        game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer({
            [1] = {["\3"] = "skip"},
            [2] = "\184"
        })
    end
end)

-- Coin detection
workspace.ChildAdded:Connect(function(child)
    if child.Name == "Coin" then
        GreggCoin = true
        RealCoin = child
    end
end)

-- Remove dangerous effects
workspace.ChildAdded:Connect(function(child)
    if child:IsA("Part") and child.Name == "pulseWavesWave" then
        child:Destroy()
    elseif child:IsA("MeshPart") and child.Name == "groundAura" then
        child:Destroy()
    elseif child:IsA("Model") and child.Name == "pulseWavesHitbox" then
        child:Destroy()
    end
end)

-- Initialize
task.spawn(function()
    repeat task.wait() until Character:FindFirstChild("HumanoidRootPart") and Player.PlayerGui:FindFirstChild("HUD")
    GetBestDungeon()
    DungeonNameDropdown:Set(BestDungeon)
    DifficultyDropdown:Set(BestDifficulty)
    
    Rayfield:Notify({
        Title = "Dungeon Quest Loaded",
        Content = string.format("Loaded in %.2f seconds - FPS Boost & Map Hiding Applied", tick() - oldTick),
        Duration = 5,
    })
end)

Rayfield:LoadConfiguration()
